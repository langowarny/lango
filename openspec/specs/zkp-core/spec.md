## ADDED Requirements

### Requirement: ProverService Lifecycle and Scheme Selection

The `ProverService` SHALL support two proving schemes: `"plonk"` (default) and `"groth16"`. The scheme SHALL be set at construction time via `Config.Scheme` and SHALL NOT change after construction. If `Config.Scheme` is empty, the service SHALL default to `"plonk"`. The service SHALL create and maintain a cache directory at `{CacheDir}` (defaulting to `~/.lango/zkp/cache`) with permissions `0700`. An unsupported scheme name MUST cause `Compile` and `Prove` to return an error.

#### Scenario: Default scheme is plonk
- **WHEN** `NewProverService` is called with an empty `Config.Scheme`
- **THEN** `ProverService.Scheme()` SHALL return `"plonk"`

#### Scenario: Unsupported scheme rejected at compile time
- **WHEN** a `ProverService` is created with `Scheme: "snark"` and `Compile` is called
- **THEN** `Compile` SHALL return an error containing "unsupported proving scheme"

#### Scenario: Cache directory created on initialization
- **WHEN** `NewProverService` is called with a non-existent `CacheDir`
- **THEN** the directory SHALL be created with permissions `0700`

---

### Requirement: Circuit Compilation and Idempotency

`ProverService.Compile` SHALL compile the given `frontend.Circuit` using the BN254 scalar field and the configured scheme's constraint system builder (`scs.NewBuilder` for PlonK, `r1cs.NewBuilder` for Groth16). A SRS SHALL be generated for PlonK using `unsafekzg.NewSRS`. Proving and verifying keys SHALL be derived via `plonk.Setup` or `groth16.Setup`. If a circuit with the given `circuitID` is already compiled, `Compile` SHALL return nil without recompiling.

#### Scenario: Circuit compiled and cached on first call
- **WHEN** `Compile("ownership", &WalletOwnershipCircuit{})` is called for the first time
- **THEN** the circuit SHALL be compiled, keys generated, and stored in the compiled map under `"ownership"`

#### Scenario: Second compile call is a no-op
- **WHEN** `Compile("ownership", ...)` is called after a successful first compilation
- **THEN** `Compile` SHALL return nil immediately without recompiling

#### Scenario: Compilation error returns wrapped error
- **WHEN** `frontend.Compile` fails for the given circuit
- **THEN** `Compile` SHALL return an error containing `compile circuit "ownership"`

---

### Requirement: Proof Generation

`ProverService.Prove` SHALL create a full witness and public witness from the circuit assignment, generate a proof using the compiled proving key, serialize the proof to bytes, and return a `Proof` struct containing `Data`, `PublicInputs`, `CircuitID`, and `Scheme`. The circuit MUST be compiled before `Prove` can be called.

#### Scenario: Proof generated for compiled circuit
- **WHEN** `Prove(ctx, "ownership", assignment)` is called on a compiled circuit
- **THEN** the returned `Proof` SHALL have non-empty `Data`, the correct `CircuitID="ownership"`, and `Scheme` matching the service scheme

#### Scenario: Uncompiled circuit returns error
- **WHEN** `Prove(ctx, "missing", assignment)` is called for a circuit ID that was never compiled
- **THEN** `Prove` SHALL return an error containing `circuit "missing" not compiled`

#### Scenario: Invalid assignment returns witness error
- **WHEN** `Prove` is called with an assignment that is inconsistent with the circuit constraints
- **THEN** `Prove` SHALL return an error from the proving step

---

### Requirement: Proof Verification

`ProverService.Verify` SHALL deserialize the proof bytes, reconstruct the public witness from the provided circuit (public inputs only), and call `plonk.Verify` or `groth16.Verify` against the compiled verifying key. A cryptographically invalid proof SHALL return `(false, nil)`. An empty or nil proof SHALL return `(false, error)`.

#### Scenario: Valid proof verifies successfully
- **WHEN** `Verify(ctx, proof, circuit)` is called with a proof generated by `Prove` for the same circuit
- **THEN** `Verify` SHALL return `(true, nil)`

#### Scenario: Tampered proof returns false
- **WHEN** `Verify` is called with a `Proof.Data` that has been modified after generation
- **THEN** `Verify` SHALL return `(false, nil)` (cryptographic failure, not a Go error)

#### Scenario: Empty proof data returns error
- **WHEN** `Verify` is called with a `Proof` where `Data` is nil or empty
- **THEN** `Verify` SHALL return `(false, error)` containing "empty proof"

---

### Requirement: WalletOwnershipCircuit (Circuit ID: "ownership")

The `WalletOwnershipCircuit` SHALL prove knowledge of a `Response` such that `MiMC(Response, Challenge) == PublicKeyHash`. Public inputs are `PublicKeyHash` and `Challenge`. The private witness is `Response`. This circuit is used during handshake to prove control of the DID private key without revealing it.

#### Scenario: Valid witness satisfies circuit
- **WHEN** `Define` is called with a `Response` such that `MiMC(Response, Challenge) == PublicKeyHash`
- **THEN** the circuit constraints SHALL be satisfied (no assertion failure)

#### Scenario: Invalid witness fails circuit
- **WHEN** `Define` is called with a `Response` that does not satisfy the MiMC equation
- **THEN** the constraint `api.AssertIsEqual(computed, c.PublicKeyHash)` SHALL fail

---

### Requirement: BalanceRangeCircuit (Circuit ID: "balance_range")

The `BalanceRangeCircuit` SHALL prove that a private `Balance` is greater than or equal to a public `Threshold`, without revealing the actual balance value. The constraint is `AssertIsLessOrEqual(Threshold, Balance)`. This circuit is used to prove USDC balance sufficiency for payment-gated capabilities.

#### Scenario: Balance at threshold satisfies circuit
- **WHEN** `Balance == Threshold`
- **THEN** the circuit SHALL be satisfied

#### Scenario: Balance below threshold fails circuit
- **WHEN** `Balance < Threshold`
- **THEN** `AssertIsLessOrEqual` SHALL fail

---

### Requirement: ResponseAttestationCircuit (Circuit ID: "attestation")

The `ResponseAttestationCircuit` SHALL prove that an agent produced a specific response from specific source data without revealing the source data or agent key. Constraints: `MiMC(AgentKeyProof) == AgentDIDHash` AND `MiMC(SourceDataHash, AgentKeyProof, Timestamp) == ResponseHash`. Public inputs are `ResponseHash`, `AgentDIDHash`, and `Timestamp`. Private witnesses are `SourceDataHash` and `AgentKeyProof`.

#### Scenario: Valid attestation witness satisfies both constraints
- **WHEN** all MiMC equations hold for the given witness
- **THEN** both `AssertIsEqual` constraints SHALL pass

#### Scenario: Wrong agent key fails DID hash check
- **WHEN** `MiMC(AgentKeyProof) != AgentDIDHash`
- **THEN** the first `AssertIsEqual` SHALL fail

---

### Requirement: AgentCapabilityCircuit (Circuit ID: "capability")

The `AgentCapabilityCircuit` SHALL prove that an agent has a capability with an `ActualScore >= MinScore` and that `MiMC(TestHash, ActualScore) == CapabilityHash`, without revealing `ActualScore` or `TestHash`. Public inputs are `CapabilityHash`, `AgentDIDHash`, and `MinScore`. Private witnesses are `ActualScore` and `TestHash`.

#### Scenario: Score above minimum satisfies circuit
- **WHEN** `ActualScore >= MinScore` and `MiMC(TestHash, ActualScore) == CapabilityHash`
- **THEN** both constraints SHALL be satisfied

#### Scenario: Score below minimum fails circuit
- **WHEN** `ActualScore < MinScore`
- **THEN** `AssertIsLessOrEqual(MinScore, ActualScore)` SHALL fail
